// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "AutonomousDriveStraight.h"
#include "Pigeon.h"

#define SPEED_ADJ_RATE 0
#define ANGLE_ERROR 1.5

double leftSpeed;
double rightSpeed;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousDriveStraight::AutonomousDriveStraight(double distance): Command() {
    m_distance = distance;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drive.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousDriveStraight::Initialize() {
	Robot::drive->ResetEncoders(); //Resets encoders so that they start at 0
	Pigeon::ResetYaw();
	printf("init");

	rightSpeed = -0.19;
	leftSpeed = -0.2;


}

// Called repeatedly when this Command is scheduled to run
void AutonomousDriveStraight::Execute() {
	double currentYaw = Pigeon::GetYaw();

	if(m_distance >= 0){
		if(currentYaw > ANGLE_ERROR){ 		//if we're veering to the left going forward
			rightSpeed += SPEED_ADJ_RATE;	//slow down the right side
		}
		else{								//if we're veering to the right going forward
			leftSpeed += SPEED_ADJ_RATE;	//slow down the left side
		}
	}
	else if(m_distance < 0){
		rightSpeed *= -1.0;					//negates direction
		leftSpeed *= -1.0;

		if(currentYaw > ANGLE_ERROR){		//if we're veering to the left going backwards
			rightSpeed += SPEED_ADJ_RATE;	//slow down right side by making it closer to 0
		}
		else{
			leftSpeed += SPEED_ADJ_RATE;
		}
	}

	Robot::drive->TankDrive(leftSpeed, rightSpeed);


}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousDriveStraight::IsFinished() {

	double driveEncVal = Robot::drive->GetLeftEncoderValue();
	if(m_distance-driveEncVal < 1){
		return true;
	}
	else{
		return false;
	}
}




// Called once after isFinished returns true
void AutonomousDriveStraight::End() {
	Robot::drive->TankDrive(0.0, 0.0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousDriveStraight::Interrupted() {

}
