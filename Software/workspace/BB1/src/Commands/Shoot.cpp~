// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Shoot.h"
#include "../Lookup.h"

#include <ntcore.h>
#include "NetworkTables/NetworkTable.h"

using std::shared_ptr;
using namespace std;

#define vision_working 0

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

Shoot::Shoot(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::shooter.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void Shoot::Initialize() {

}

// Called repeatedly when this Command is scheduled to run
void Shoot::Execute() {


		shared_ptr<NetworkTable> myTable = NetworkTable::GetTable("Vision"); // setup network table from RPi
		double distance = 0.0 ; // distance provided by RPi is float
		int dist = 0; // distance in look up table is integer

		int speed, position; // speed and position variables
		speed = 45;        // default speed
		position = 99;      // default position

		myTable->GetNumber("Distance", distance); // get distance from network tables
		dist = int(distance); // convert to integer

	    results mytest = interp( dist ); // call linear interpolation function

	    if (vision_working) {
	    	speed = mytest.speed;  // get speed in RPM
	    	position = mytest.position;  // get position
	    }

        printf("%d shooter speed %d shooter position\n", speed, position);

		//Robot::shooter->SetHoodPosition(position/100);
		//Robot::shooter->Spin(speed);

        Robot::shooter->SetHoodPosition(0.2);
        Robot::shooter->Spin(-2100);
        //TODO get rid of previous lines and then replace interp stuff
	    printf("shooter execute\n");
}

// Make this return true when this Command no longer needs to run execute()

bool Shoot::IsFinished() {

	// // when the button is released the return is true stopping the command
	bool buttonVal = Robot::oi->getManipulator()->GetRawButton(1);
    return !buttonVal;   // // inverted as true is stop
}

// Called once after isFinished returns true
void Shoot::End() {
	Robot::shooter->Stop();
	//Robot::shooter->SetHoodPosition(0.2);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void Shoot::Interrupted() {

}
